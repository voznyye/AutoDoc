import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { GitUtils } from '../utils/gitUtils';

export interface GitHookConfig {
    preCommit: {
        enabled: boolean;
        updateDocs: boolean;
        validateDocs: boolean;
        failOnError: boolean;
    };
    postCommit: {
        enabled: boolean;
        publishDocs: boolean;
        notifyTeam: boolean;
    };
}

export interface CommitAnalysis {
    changedFiles: string[];
    addedFiles: string[];
    deletedFiles: string[];
    modifiedFunctions: any[];
    impactedDocuments: string[];
    suggestedUpdates: string[];
}

export class GitHookProvider {
    private gitUtils: GitUtils;

    constructor(_context: vscode.ExtensionContext) {
        this.gitUtils = new GitUtils();
    }

    public async setupHooks(): Promise<void> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            vscode.window.showErrorMessage('No workspace folder found for Git hook setup');
            return;
        }

        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        const gitHooksPath = path.join(workspaceRoot, '.git', 'hooks');

        try {
            // Check if .git directory exists
            if (!fs.existsSync(path.join(workspaceRoot, '.git'))) {
                vscode.window.showWarningMessage('This is not a Git repository. Git hooks will not be installed.');
                return;
            }

            // Ensure hooks directory exists
            if (!fs.existsSync(gitHooksPath)) {
                fs.mkdirSync(gitHooksPath, { recursive: true });
            }

            const config = vscode.workspace.getConfiguration('docGenerator.gitIntegration');
            
            if (config.get('preCommitHook')) {
                await this.setupPreCommitHook(gitHooksPath, workspaceRoot);
            }

            // Setup post-commit hook if needed
            // await this.setupPostCommitHook(gitHooksPath, workspaceRoot);

            vscode.window.showInformationMessage('Git hooks installed successfully!');

        } catch (error) {
            const errorMessage = error instanceof Error ? error.message : 'Unknown error';
            vscode.window.showErrorMessage(`Failed to setup Git hooks: ${errorMessage}`);
            console.error('Git hook setup error:', error);
        }
    }

    private async setupPreCommitHook(gitHooksPath: string, workspaceRoot: string): Promise<void> {
        const preCommitPath = path.join(gitHooksPath, 'pre-commit');
        
        // Create or update pre-commit hook
        const hookScript = this.generatePreCommitScript(workspaceRoot);
        
        // If hook already exists, backup and merge
        if (fs.existsSync(preCommitPath)) {
            const existingHook = fs.readFileSync(preCommitPath, 'utf8');
            if (!existingHook.includes('# DOC-GENERATOR-HOOK')) {
                // Backup existing hook
                fs.writeFileSync(preCommitPath + '.backup', existingHook);
                // Merge with existing hook
                const mergedHook = this.mergeHooks(existingHook, hookScript);
                fs.writeFileSync(preCommitPath, mergedHook, { mode: 0o755 });
            } else {
                // Replace our section
                const updatedHook = this.updateExistingHook(existingHook, hookScript);
                fs.writeFileSync(preCommitPath, updatedHook, { mode: 0o755 });
            }
        } else {
            fs.writeFileSync(preCommitPath, hookScript, { mode: 0o755 });
        }
    }

    private generatePreCommitScript(_workspaceRoot: string): string {
        const config = vscode.workspace.getConfiguration('docGenerator.gitIntegration');
        const autoStage = config.get('autoStage');
        // const _commitMessage = config.get('commitMessage') || 'docs: update documentation';

        return `#!/bin/sh
# DOC-GENERATOR-HOOK START
# Auto-generated by Documentation Generator Extension

echo "üîç Checking for documentation updates..."

# Check if any code files have been modified
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep -E '\\.(ts|tsx|js|jsx|py|java|cs|go|rs|php)$' || true)

if [ -n "$CHANGED_FILES" ]; then
    echo "üìù Code changes detected, updating documentation..."
    
    # Run documentation update through VS Code extension
    # This will be handled by the extension's file watcher or manual trigger
    
    # For now, we'll create a marker file that the extension can detect
    echo "$(date)" > .doc-update-requested
    
    ${autoStage ? `
    # Auto-stage documentation files if they exist
    if [ -f "README.md" ]; then
        git add README.md
        echo "‚úÖ Staged README.md"
    fi
    
    if [ -d "docs" ]; then
        git add docs/
        echo "‚úÖ Staged docs/ directory"
    fi
    
    if [ -f "CHANGELOG.md" ]; then
        git add CHANGELOG.md
        echo "‚úÖ Staged CHANGELOG.md"
    fi
    ` : ''}
    
    echo "‚ú® Documentation update process completed"
else
    echo "‚ÑπÔ∏è  No code changes detected, skipping documentation update"
fi

# DOC-GENERATOR-HOOK END
`;
    }

    private mergeHooks(existingHook: string, newHook: string): string {
        return existingHook + '\n\n' + newHook;
    }

    private updateExistingHook(existingHook: string, newHook: string): string {
        const startMarker = '# DOC-GENERATOR-HOOK START';
        const endMarker = '# DOC-GENERATOR-HOOK END';
        
        const startIndex = existingHook.indexOf(startMarker);
        const endIndex = existingHook.indexOf(endMarker);
        
        if (startIndex !== -1 && endIndex !== -1) {
            // Replace the existing hook section
            return existingHook.substring(0, startIndex) + 
                   newHook + 
                   existingHook.substring(endIndex + endMarker.length);
        } else {
            // Append new hook
            return existingHook + '\n\n' + newHook;
        }
    }

    public async analyzeCommit(workspaceRoot: string): Promise<CommitAnalysis> {
        try {
            const stagedFiles = await this.gitUtils.getStagedFiles(workspaceRoot);
            
            // Analyze what files are being committed
            const analysis: CommitAnalysis = {
                changedFiles: stagedFiles.modified,
                addedFiles: stagedFiles.added,
                deletedFiles: stagedFiles.deleted,
                modifiedFunctions: [], // This would be populated by code analysis
                impactedDocuments: [],
                suggestedUpdates: []
            };

            // Determine which documentation files might be impacted
            analysis.impactedDocuments = this.getImpactedDocuments(analysis.changedFiles);
            
            // Generate suggestions for documentation updates
            analysis.suggestedUpdates = this.generateUpdateSuggestions(analysis);

            return analysis;

        } catch (error) {
            console.error('Error analyzing commit:', error);
            return {
                changedFiles: [],
                addedFiles: [],
                deletedFiles: [],
                modifiedFunctions: [],
                impactedDocuments: [],
                suggestedUpdates: []
            };
        }
    }

    private getImpactedDocuments(changedFiles: string[]): string[] {
        const impactedDocs: string[] = [];
        
        // Check if README.md needs updating
        if (changedFiles.some(file => 
            file.includes('package.json') || 
            file.includes('README') ||
            file.match(/\.(ts|js|py)$/)
        )) {
            impactedDocs.push('README.md');
        }

        // Check if API documentation needs updating
        if (changedFiles.some(file => file.match(/\.(ts|tsx|js|jsx)$/))) {
            impactedDocs.push('docs/API.md');
        }

        // Check if CHANGELOG needs updating
        if (changedFiles.length > 0) {
            impactedDocs.push('CHANGELOG.md');
        }

        return impactedDocs;
    }

    private generateUpdateSuggestions(analysis: CommitAnalysis): string[] {
        const suggestions: string[] = [];

        if (analysis.addedFiles.length > 0) {
            suggestions.push(`Document ${analysis.addedFiles.length} new file(s) in API documentation`);
        }

        if (analysis.modifiedFunctions.length > 0) {
            suggestions.push(`Update documentation for ${analysis.modifiedFunctions.length} modified function(s)`);
        }

        if (analysis.changedFiles.some(file => file.includes('package.json'))) {
            suggestions.push('Update README.md with new dependencies or version changes');
        }

        if (analysis.changedFiles.length > 0) {
            suggestions.push('Add entry to CHANGELOG.md describing the changes');
        }

        return suggestions;
    }

    public async handlePreCommit(workspaceRoot: string): Promise<boolean> {
        try {
            console.log('Handling pre-commit hook...');
            
            // Check if documentation update was requested
            const updateRequestFile = path.join(workspaceRoot, '.doc-update-requested');
            if (fs.existsSync(updateRequestFile)) {
                // Remove the marker file
                fs.unlinkSync(updateRequestFile);
                
                // Trigger AI documentation update via command
                vscode.window.showInformationMessage(
                    'Code changes detected. Updating documentation with AI...'
                );
                
                // Trigger the AI update command
                vscode.commands.executeCommand('docGenerator.updateDocs');
            }

            return true; // Allow commit to proceed

        } catch (error) {
            console.error('Error in pre-commit hook:', error);
            
            const config = vscode.workspace.getConfiguration('docGenerator.gitIntegration');
            const failOnError = config.get('failOnError', false);
            
            if (failOnError) {
                vscode.window.showErrorMessage(
                    'Documentation update failed. Commit blocked. Fix the issues and try again.'
                );
                return false; // Block commit
            } else {
                vscode.window.showWarningMessage(
                    'Documentation update failed, but commit will proceed.'
                );
                return true; // Allow commit
            }
        }
    }

    public async removeHooks(): Promise<void> {
        const workspaceFolders = vscode.workspace.workspaceFolders;
        if (!workspaceFolders || workspaceFolders.length === 0) {
            return;
        }

        const workspaceRoot = workspaceFolders[0].uri.fsPath;
        const preCommitPath = path.join(workspaceRoot, '.git', 'hooks', 'pre-commit');

        try {
            if (fs.existsSync(preCommitPath)) {
                const hookContent = fs.readFileSync(preCommitPath, 'utf8');
                
                // Remove only our section
                const startMarker = '# DOC-GENERATOR-HOOK START';
                const endMarker = '# DOC-GENERATOR-HOOK END';
                
                const startIndex = hookContent.indexOf(startMarker);
                const endIndex = hookContent.indexOf(endMarker);
                
                if (startIndex !== -1 && endIndex !== -1) {
                    const updatedHook = hookContent.substring(0, startIndex) + 
                                      hookContent.substring(endIndex + endMarker.length);
                    
                    if (updatedHook.trim()) {
                        fs.writeFileSync(preCommitPath, updatedHook, { mode: 0o755 });
                    } else {
                        fs.unlinkSync(preCommitPath);
                    }
                }
            }

            vscode.window.showInformationMessage('Git hooks removed successfully!');

        } catch (error) {
            console.error('Error removing Git hooks:', error);
            vscode.window.showErrorMessage('Failed to remove Git hooks');
        }
    }

    public cleanup(): void {
        // Cleanup any resources or listeners
        console.log('GitHookProvider cleanup completed');
    }
}
